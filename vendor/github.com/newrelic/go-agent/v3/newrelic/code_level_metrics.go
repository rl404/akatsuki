// Copyright 2022 New Relic Corporation. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

package newrelic

import (
	"errors"
	"reflect"
	"runtime"
	"strings"
)

//
// defaultAgentProjectRoot is the default filename pattern which is at
// the root of the agent's import path. This is used to identify functions
// on the call stack which are assumed to belong to the agent rather than
// the instrumented application's code.
//
const defaultAgentProjectRoot = "github.com/newrelic/go-agent/"

//
// CodeLocation marks the location of a line of source code for later reference.
//
type CodeLocation struct {
	// LineNo is the line number within the source file.
	LineNo int
	// Function is the function name (note that this may be auto-generated by Go
	// for function literals and the like). This is the fully-qualified name, which
	// includes the package name and other information to unambiguously identify
	// the function.
	Function string
	// FilePath is the absolute pathname on disk of the source file referred to.
	FilePath string
}

type traceOptSet struct {
	LocationOverride *CodeLocation
	SuppressCLM      bool
	IgnoredPrefix    string
}

//
// TraceOption values provide optional parameters to transactions.
//
type TraceOption func(*traceOptSet)

//
// WithCodeLocation adds an explicit CodeLocation value
// to report for the Code Level Metrics attached to a trace.
// This is probably a value previously obtained by calling
// ThisCodeLocation().
//
func WithCodeLocation(loc *CodeLocation) TraceOption {
	return func(o *traceOptSet) {
		o.LocationOverride = loc
	}
}

//
// WithIgnoredPrefix indicates that the code location reported
// for Code Level Metrics should be the first function in the
// call stack that does not begin with the given string. This
// string is matched against the entire fully-qualified function
// name, which includes the name of the package the function
// comes from. By default, the Go Agent tries to take the first
// function on the call stack that doesn't seem to be internal to
// the agent itself, but you can control this behavior using
// this option.
//
// If all functions in the call stack begin with this prefix,
// the outermos one will be used anyway, since we didn't find
// anything better on the way to the bottom of the stack.
//
func WithIgnoredPrefix(prefix string) TraceOption {
	return func(o *traceOptSet) {
		o.IgnoredPrefix = prefix
	}
}

//
// WithoutCodeLevelMetrics suppresses the collection and reporting
// of Code Level Metrics for this trace. This helps avoid the overhead
// of collecting that information if it's not needed for certain traces.
//
func WithoutCodeLevelMetrics() TraceOption {
	return func(o *traceOptSet) {
		o.SuppressCLM = true
	}
}

//
// WithThisCodeLocation is equivalent to calling WithCodeLocation, referring
// to the point in the code where the WithThisCodeLocation call is being made.
// This can be helpful, for example, when the actual code invocation which starts
// a transaction or other kind of trace is originating from a framework or other
// centralized location, but you want to report this point in your application
// for the Code Level Metrics associated with this trace.
//
func WithThisCodeLocation() TraceOption {
	return WithCodeLocation(ThisCodeLocation(1))
}

//
// FunctionLocation is like ThisCodeLocation, but takes as its parameter
// a function value. It will report the code-level metrics information for
// that function if that is possible to do. It returns an error if it
// was not possible to get a code location from the parameter passed to it.
//
func FunctionLocation(function interface{}) (*CodeLocation, error) {
	if function == nil {
		return nil, errors.New("nil function passed to FunctionLocation")
	}

	v := reflect.ValueOf(function)
	if !v.IsValid() || v.Kind() != reflect.Func {
		return nil, errors.New("value passed to FunctionLocation is not a function")
	}

	if fInfo := runtime.FuncForPC(v.Pointer()); fInfo != nil {
		var loc CodeLocation

		loc.FilePath, loc.LineNo = fInfo.FileLine(fInfo.Entry())
		loc.Function = fInfo.Name()
		return &loc, nil
	}

	return nil, errors.New("could not find code location for function")
}

//
// WithFunctionLocation is like WithThisCodeLocation, but uses the
// function value passed as the location to report. Unlike FunctionLocation,
// this does not report errors explicitly. If it is unable to use the
// value passed to find a code location, it will do nothing.
//
func WithFunctionLocation(function interface{}) TraceOption {
	return func(o *traceOptSet) {
		loc, err := FunctionLocation(function)
		if err == nil {
			o.LocationOverride = loc
		}
	}
}

//
// ThisCodeLocation returns a CodeLocation value referring to
// the place in your code that it was invoked.
//
// With no arguments (or if passed a 0 value), it returns the location
// of its own caller. However, you may adjust this by passing the number
// of function calls to skip. For example, ThisCodeLocation(1) will return
// the CodeLocation of the place the current function was called from
// (i.e., the caller of the caller of ThisCodeLocation).
//
func ThisCodeLocation(skipLevels ...int) *CodeLocation {
	var loc CodeLocation
	skip := 2
	if len(skipLevels) > 0 {
		skip += skipLevels[0]
	}

	pcs := make([]uintptr, 10)
	depth := runtime.Callers(skip, pcs)
	if depth > 0 {
		frames := runtime.CallersFrames(pcs[:1])
		frame, _ := frames.Next()
		loc.LineNo = frame.Line
		loc.Function = frame.Function
		loc.FilePath = frame.File
	}
	return &loc
}

func removeCodeLevelMetrics(remAttr func(string)) {
	remAttr(AttributeCodeLineno)
	remAttr(AttributeCodeNamespace)
	remAttr(AttributeCodeFilepath)
	remAttr(AttributeCodeFunction)
}

func reportCodeLevelMetrics(tOpts traceOptSet, run *appRun, setAttr func(string, string, interface{})) {
	var location CodeLocation

	if tOpts.LocationOverride != nil {
		location = *tOpts.LocationOverride
	} else {
		pcs := make([]uintptr, 10)
		depth := runtime.Callers(2, pcs)
		if depth > 0 {
			frames := runtime.CallersFrames(pcs[:depth])
			moreToRead := true
			var frame runtime.Frame

			if tOpts.IgnoredPrefix == "" {
				tOpts.IgnoredPrefix = run.Config.CodeLevelMetrics.IgnoredPrefix
				if tOpts.IgnoredPrefix == "" {
					tOpts.IgnoredPrefix = defaultAgentProjectRoot
				}
			}

			// skip out to first non-agent frame, unless that IS the top-most frame
			for moreToRead {
				frame, moreToRead = frames.Next()
				if !strings.HasPrefix(frame.Function, tOpts.IgnoredPrefix) {
					break
				}
			}

			location.FilePath = frame.File
			location.Function = frame.Function
			location.LineNo = frame.Line
		}
	}

	if run.Config.CodeLevelMetrics.PathPrefix != "" {
		if pi := strings.Index(location.FilePath, run.Config.CodeLevelMetrics.PathPrefix); pi > 0 {
			location.FilePath = location.FilePath[pi:]
		}
	}

	ns := strings.LastIndex(location.Function, ".")
	function := location.Function
	namespace := ""

	if ns >= 0 {
		namespace = location.Function[:ns]
		function = location.Function[ns+1:]
	}

	setAttr(AttributeCodeLineno, "", location.LineNo)
	setAttr(AttributeCodeNamespace, namespace, nil)
	setAttr(AttributeCodeFilepath, location.FilePath, nil)
	setAttr(AttributeCodeFunction, function, nil)
}
